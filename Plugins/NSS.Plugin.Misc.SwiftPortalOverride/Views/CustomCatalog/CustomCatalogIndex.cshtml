@using Syncfusion.EJ2
@using NSS.Plugin.Misc.SwiftPortalOverride.Models
@model CatalogModel

@{
    Layout = "_ColumnsOne";

    //page class
    Html.AppendPageCssClassParts("html-home-page");
}

<div id="app" class="page catalog-page">
    <div class="page-body">
        <div class="row">
            <div class="col-md-4 col-lg-3 col-xl-3 shapes-treeview">
                <div class="cart-side-drawer-trigger">
                    <img src="Themes/SwiftPortal/Content/assets/settings-adjust.svg" alt="">
                </div>

                <div class="cat-side-drawer">

                    <div id="accordion">
                        <div class="card">
                            <a class="card-link" data-toggle="collapse" href="#collapseOne" id="shapes-header"
                               v-on:click="toggleHeader('shapes-header')">
                                <div class="card-header">SHAPES</div>
                            </a>
                            <div id="collapseOne" class="collapse show">
                                <div>
                                    <div id="treeview"></div>
                                </div>
                            </div>
                        </div>

                        <div class="card" style="display: flex" v-for="(specs, index) in defaultSpecs">
                            <a :id="'default-spec-header-' + index" class="card-link" data-toggle="collapse" :href="'#default-spec-collapse-' + index"
                               v-on:click="toggleHeader('default-spec-header-' + index)">
                                <div class="card-header">{{ specs[0].name }}</div>
                            </a>
                            <div :id="'default-spec-collapse-' + index" class="collapse show" v-for="spec in specs">
                                <div class="card-body">
                                    <label class="pure-material-checkbox">
                                        <input :id="'checkbox-' + spec.specificationAttributeOptionId"
                                               type="checkbox" v-bind:checked="spec.checked" v-on:change="toggleSpec(spec)">
                                        <span class="checkmark"></span>{{ spec.displayName }}
                                    </label>
                                </div>
                            </div>
                        </div>
                        <div class="card" style="display: flex" v-if="showOtherSpecs" v-for="(specs, index) in otherSpecs">
                            <a :id="'other-spec-header-' + index" class="card-link" data-toggle="collapse" :href="'#other-spec-collapse-' + index"
                               v-on:click="toggleHeader('other-spec-header-' + index)">
                                <div class="card-header">{{ specs[0].name }}</div>
                            </a>
                            <div :id="'other-spec-collapse-' + index" class="collapse show" v-for="spec in specs">
                                <div class="card-body">
                                    <label class="pure-material-checkbox">
                                        <input :id="'checkbox-' + spec.specificationAttributeOptionId"
                                               type="checkbox" v-bind:checked="spec.checked" v-on:change="toggleSpec(spec)">
                                        <span class="checkmark"></span>{{ spec.displayName }}
                                    </label>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="col-md-8 col-lg-9 col-xl-9">
                <div class="d-flex flex-row mb-3" v-if="filterTags.length > 0">
                    <div v-for="tag in filterTags" class="d-flex flex-row">
                        <span class="filter-tag">
                            {{ tag.text }}
                            <button v-on:click='removeFilter(tag)'>
                                <img alt="close icon" src="Themes/SwiftPortal/Content/assets/close-filled.svg" width="15" height="15" />
                            </button>
                        </span>
                    </div>
                    <button v-on:click="clearFilters" class="clear-filter ml-4">Clear filters</button>
                </div>
                <div id="partialview"></div>
            </div>
        </div>
    </div>
</div>

@functions{
    @using Newtonsoft.Json.Serialization;
    @using Newtonsoft.Json;

    string Serialize(object input)
    {
        return JsonConvert.SerializeObject(input, new JsonSerializerSettings
        {
            ContractResolver = new DefaultContractResolver { NamingStrategy = new CamelCaseNamingStrategy() },
            Formatting = Formatting.None
        });
    }
}

<script>
    let gridData = [];
    let gridColumns = [];
    const store = {
        state: {
            groupedSpecs: [],
            groupedShapes: [],

            constants: {
                SPEC_TYPE_DEFAULT: 1,
                SPEC_TYPE_OTHERS: 2,
            }
        },
    }

    const shopVm = new Vue({
        el: '#app',
        data: {
            shared: store.state,
            specNames: [],
            shapeNames: [],
            specIDs: [],
            shapeIDs: [],
            filterTags: [],
            groupedSpecs: [],
            treeview: null,
            checkedNodes: [],
        },
        mounted: function () {
            this.getFilteredProduuts();
            //this.prepareGroupedSpecs();

            ej.base.enableRipple(false);

            //Initialize TreeView component
            this.treeview = new ej.navigations.TreeView({
                fields: { dataSource: this.shared.groupedShapes, id: 'id', parentID: 'parentId', text: 'displayName', hasChildren: 'hasChild' },
                showCheckBox: true, autoCheck: false, cssClass: 'custom',
                nodeChecked: this.nodeChecked,
            });

            //Render initialized TreeView
            this.treeview.appendTo("#treeview");
        },
        computed: {
            defaultSpecs: function () {
                return this.groupedSpecs.filter(x => x[0].type === this.shared.constants.SPEC_TYPE_DEFAULT);
            },
            otherSpecs: function () {
                return this.groupedSpecs.filter(x => x[0].type === this.shared.constants.SPEC_TYPE_OTHERS);
            },
            showOtherSpecs: function () {
                return this.filterTags.some(x => x.type === 'shape' && (x.id === 13 || x.parentId === 13));
            },
        },
        methods: {
            showLoading: function () {
                $('#custom-loading').show();
            },
            hideLoading: function () {
                $('#custom-loading').hide();
            },
            prepareGroupedSpecs: function () {
                this.shared.groupedSpecs.forEach((specs, index) => {
                    specs.forEach(spec => {
                        let name = '';
                        let type = this.shared.constants.SPEC_TYPE_OTHERS;
                        switch (spec.specificationAttributeName) {
                            case "coating":
                                name = "COATING";
                                type = this.shared.constants.SPEC_TYPE_DEFAULT;
                                break;
                            case "condition":
                                name = "CONDITION";
                                break;
                            case "countryOfOrigin":
                                name = "COUNTRY OF ORIGIN";
                                break;
                            case "displayThickness":
                                name = "THICKNESS (in)";
                                break;
                            case "displayWidth":
                                name = "MINIMUM WIDTH (in)";
                                break;
                            case "grade":
                                name = "GRADES";
                                break;
                            case "metal":
                                name = "METAL";
                                type = this.shared.constants.SPEC_TYPE_DEFAULT;
                                break;
                            default:
                                name = spec.specificationAttributeName;
                                break;
                        }
                        spec.name = name;
                        spec.type = type;
                        spec.displayName = `${spec.specificationAttributeOptionName} (${spec.productCount})`;
                        spec.checked = this.filterTags.some(x => x.type === 'spec' && x.id === spec.specificationAttributeOptionId);
                    });
                });
                console.log("grouped prepared: ", this.shared.groupedSpecs);
                this.groupedSpecs = this.shared.groupedSpecs;
            },

            nodeChecked: function (args) {
                if (!args.isInteracted) return;

                this.toggleShape(args.data[0]);
            },
            toggleShape: function (node) {
                //if (!this.treeview)
                //    this.treeview = document.getElementById('treedata').ej2_instances[0];
                // if it's checked
                    // if its topmost level, get all children and check them
                    // else
                        // add to previously selected nodes
                        // if all children in the pid are selected, add the parentId
                // else
                    // if it's topmost level, uncheck self and all children
                    // else, uncheck self and parent
                const shape = this.shared.groupedShapes.find(x => x.id == node.id);
                let resultShapes = [];
                let resultNodes = [];
                if (node.isChecked === 'true') {
                    if (!shape.parentId) { // topmost node
                        resultShapes = this.shared.groupedShapes.filter(x => x.parentId === shape.id || x.id === shape.id);
                        console.log("allNodes: ", resultShapes);
                        resultNodes = resultShapes.map(x => x.id.toString());
                    } else { // child node
                        const children = this.shared.groupedShapes.filter(x => x.parentId === shape.parentId).map(x => x.id.toString());
                        let checkedNodes = this.treeview.checkedNodes.filter(x => children.includes(x));
                        const allChildrenSelected = children.length === checkedNodes.length;
                        if (allChildrenSelected)
                            checkedNodes = [...checkedNodes, node.parentID];
                        resultNodes = [...checkedNodes];
                        resultShapes = this.shared.groupedShapes.filter(x => resultNodes.includes(x.id.toString()));
                        console.log("onlyNode: ", resultNodes);
                    }
                } else {
                    if (!shape.parentId) { // topmost node
                        resultNodes = [];
                        resultShapes = [];
                        console.log("noNode: ", resultNodes);
                    } else { // child node
                        const checkedNodes = this.treeview.checkedNodes;
                        resultNodes = checkedNodes.filter(x => x !== node.id && x !== node.parentID);
                        resultShapes = this.shared.groupedShapes.filter(x => resultNodes.includes(x.id.toString()));
                        console.log("otherNodes: ", resultNodes);
                    }
                }
                const shapeFilters = resultShapes.map(shape => {
                    return { id: shape.id, parentId: shape.parentId, text: shape.name, type: 'shape' };
                });
                this.filterTags = this.filterTags.filter(x => x.type !== 'shape');
                this.filterTags = [...this.filterTags, ...shapeFilters];
                this.getFilteredProduuts();
            },
            toggleSpec: function (spec) {
                console.log("toggleSpec: ", spec.checked);
                spec.checked = !spec.checked;
                if (spec.checked) {
                    const tag = {
                        id: spec.specificationAttributeOptionId,
                        text: spec.specificationAttributeOptionName,
                        type: 'spec',
                        data: spec,
                    };
                    this.filterTags = [...this.filterTags, tag];
                } else {
                    this.filterTags = this.filterTags.filter(x => x.id !== spec.specificationAttributeOptionId || x.type !== 'spec');
                }
                this.getFilteredProduuts();
            },

            removeFilter: function (tag) {
                const { id, type, data } = tag;
                if (type === 'shape') {
                    const parentID = this.shared.groupedShapes.find(x => x.id === id).parentId;
                    const shapeData = {
                        id: id.toString(),
                        parentID: parentID ? parentID.toString() : null,
                        isChecked: 'false',
                    };
                    this.toggleShape(shapeData);
                } else if (type === 'spec') {
                    this.toggleSpec(data);
                }
            },
            clearFilters: function () {
                this.filterTags = [];
                if (this.treeview) this.treeview.uncheckAll();
                this.groupedSpecs.forEach(specs => specs.forEach(spec => spec.checked = false));

                window.history.pushState("object or string", "Title", "/" + window.location.href.substring(window.location.href.lastIndexOf('/') + 1).split("?")[0]);

                this.getFilteredProduuts();
            },

            getFilteredProduuts: function () {
                this.showLoading();

                let searchKeyword = getUrlParameter('q');
                const shapeIds = this.filterTags.filter(x => x.type === 'shape').map(x => x.id);
                const specIds = this.filterTags.filter(x => x.type === 'spec').map(x => x.id);
                var filterParams = { SpecIds: specIds, ShapeIds: shapeIds, SearchKeyword: searchKeyword };
                const self = this;
                $.ajax({
                    url: "@Url.Action("FilteredProductsResult", "CatalogOverride")",
                    type: 'POST',
                    contentType: 'application/json; charset=utf-8',
                    data: JSON.stringify(filterParams),
                    success: function (data) {
                        if (data != null) {
                            $('#partialview').html(data.partialView);
                            self.shared.groupedShapes = JSON.parse(data.shapes);
                            self.shared.groupedSpecs = JSON.parse(data.specs);
                            self.resetTreeview();
                            self.prepareGroupedSpecs();
                        }
                        self.hideLoading();
                    },
                    error: function (xhr, ajaxOptions, thrownError) {
                        console.log(thrownError, 'datadata-error', xhr);
                        $('#partialview').html('an error has occured here');
                        self.hideLoading();
                    }
                });
            },

            resetTreeview: function () {
                const filterShapeIds = this.filterTags.filter(x => x.type === 'shape').map(x => x.id);
                this.shared.groupedShapes.forEach(shape => {
                    const childrenIds = this.shared.groupedShapes.filter(x => x.parentId === shape.id).map(x => x.id);
                    const exists = childrenIds.some(x => filterShapeIds.includes(x));
                    shape.expanded = exists;
                    shape.isChecked = filterShapeIds.includes(shape.id);
                });
                this.treeview.fields = {
                    dataSource: this.shared.groupedShapes, id: 'id', parentID: 'parentId',
                    text: 'displayName', hasChildren: 'hasChild',
                };
            },

            toggleHeader: function (id) {
                const collapsed = $('#' + id).hasClass('collapsed');
                if (collapsed) $('#' + id).removeClass('collapsed');
                else $('#' + id).addClass('collapsed');
            }
        },
    });

    function getUrlParameter(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
        var results = regex.exec(location.search);
        return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    };
</script>
<ejs-scripts></ejs-scripts>